"""
This utils module is a miscellaneous collection of tools to either manipulate the dataframe structure,
or to configure the plot figures.
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


def split_df_with(df, col_name, split_key=np.NaN, key_included=False, drop_cols=[]):

    """
    args:
        - df:              The target dataframe
        - col_name:        The column name that contains the split_key value to be used as a separator.
        - split_key:       The value as the separator. Datatype can be np.NaN, float, integer, string. 
        - key_included:    Whether to include the split_key as leading element in groups.
                           See the following introduction for more information.
        - drop_cols:       (Optional) A list of columns name to drop in the returned dataframe. This can be useful when
                           a column is only used as an indicator to split the dataframe.


    Given a dataframe with a column name, which has values of 'split_key' by which you want to split the dataframe
    into separate dataframes, this function will split it on the row of 'split_key'. For example, given a dataframe
    as the following and split_key = 0:

            Time        Glucose
                ------------------------
                0       0
                1       3.8
                2       4.8
                3       0
                4       0
                5       7.8

    The dataframe will be broken down to 3 group of dataframes, with group number incremented from 0, and the rows
    with the split_key will be grouped together in group -1.

            -1:
                Time    Glucose
                ------------------------
                0       0
                3       0
                4       0
            0: 
                Time    Glucose
                ------------------------
                1       3.8
                2       4.8
            1: 
                Time    Glucose
                ------------------------
                5       7.8


    If key_included is set to be True, then split_key 0 will be included in the group as the leading element.
    However, it is only included when its consecutive element (next row) is not another split_key.

            -1:
                Time    Glucose
                ------------------------
                3       0
            0: 
                Time    Glucose
                ------------------------
                0       0
                1       3.8
                2       4.8
            1: 
                Time    Glucose
                ------------------------
                4       0
                5       7.8

    Return a dictionary with the format:
    {
        0: split_dataframe1,
        1: split_dataframe2,
        ....,
        -1: all the rows that have split_key value.
    }
    """

    def gen_group_index(mask_series, key_included=key_included):
        """
        args:
            mask_series: a series that is composed by True/False value, where the True is the location of the separator.
                    i.e., If the separator is 0, and given a df:
                          Time    Glucose
                          ------------------------
                          0       0
                          1       3.8
                          2       4.8
                          3       0
                          4       9.5
                    The 'series' input can be generated by (df['Glucose']==0), and it yields:
                          0       True
                          1       False
                          2       False
                          3       True
                          4       False

        return:
            a series that is composed by positive integer for group number, and -1 for the separator.
            The group index starts off at 0, and increment by 1.
                    i.e.
                          0       -1
                          1       0
                          2       0
                          3       -1
                          4       1
        
        * Logic of this function
        [1] key_included: False 
        # Original:         [True, False, False, True, False]
        # Reverse:          [False, True, True, False, True]
        # As int:           [0,     1,    1,    0,     1]
        # Diff:             [0,     1,    0,   -1,     1]
        # Max(0,x):         [0,     1,    0,    0,     0]
        # cumsum():         [0,     1,    1,    1,     2]
        # Map origin keys:  [-1,    1,    1,   -1,     2]
        # Adjust min group: [-1,    0,    0,   -1,     1]

        [2] key_included: True
        # Original:         [True, False, True, True, False]
        # As int:           [1,     0,    1,    1,     0]
        # Diff:             [0,    -1,    1,    0,    -1]
        # Max(0,x):         [0,     0,    1,    0,     0]
        # cumsum():         [0,     0,    1,    1,     1]
        # Map cont. keys:   [0,     0,   -1,    1,     1]
        # Adjust min group: [0,     0,   -1,    1,     1]
        """

        mask_series = mask_series.copy()

        if key_included == False:
            group_idx = (~mask_series).astype(int).diff().fillna(0).apply(lambda x: max(x,0)).cumsum()
            # Map origin keys:
            group_idx.loc[mask_series] = -1

        else:
            group_idx = mask_series.astype(int).diff().fillna(0).apply(lambda x: max(x,0)).cumsum()
            # Map continuous keys:
            group_idx.loc[(mask_series.astype(int) + mask_series.astype(int).shift(-1).fillna(0)) == 2] = -1

        # Adjust min group
        if group_idx[~(group_idx<0)].min() != 0:
            group_idx.loc[~(group_idx<0)] -= 1
        return group_idx


    df = df.copy()

    # Note: NaN equality comparison cannot be done by == operator: i.e., (if x == np.NaN)
    if pd.isna(split_key):
        df['group_no'] = gen_group_index(pd.isna(df[col_name]))

    else:
        df['group_no'] = gen_group_index(df[col_name]==split_key)
    
    # Store the split splines into a dictionary
    d = {int(g): df.loc[rows].drop(columns=['group_no']+drop_cols).copy()
        for g, rows in df.groupby('group_no').groups.items()}
    
    return d


def find_pattern(df, pattern, col_name, backfill=False):
    """
    args:
        df:       a dataframe
        pattern:  a list, which can be string, int, floats.
        col_name: the column in the dataframe to search the pattern.
        backfill: See the introduction below.
    returns:
        match_array: The return values is an array which is composed by 0 and 1, where 1 is where the pattern is found.
                     See the introduction below.

    Given a dataframe df and a list of pattern, i.e., pattern = [1,2,3]

    [If backfill==True] All the matched pattern would have marked as 1
    index   col_name    pattern
    -----------------------------
    0       1           0
    1       1           1
    2       2           1
    3       3           1
    4       0           0              
    5       1           1
    6       2           1
    7       3           1

    [If backfill==False] Only the last element in the matched pattern is marked as 1
    index   col_name    pattern
    -----------------------------
    0       1           0
    1       1           0
    2       2           0
    3       3           1
    4       0           0              
    5       1           0
    6       2           0
    7       3           1
    """
    pattern = np.asarray(pattern)

    if backfill==True:
        pattern_match = df[col_name].rolling(window=len(pattern), min_periods=len(pattern))  \
                            .apply(lambda x: (x==pattern).all())                      \
                            .mask(lambda x: x==0)                                     \
                            .bfill(limit=max(1, len(pattern)-1))                      \
                            .fillna(0)
        
        return pattern_match
        
    else:
        pattern_match = df[col_name].rolling(window=len(pattern), min_periods=len(pattern))  \
                            .apply(lambda x: (x==pattern).all())                      \
                            .fillna(0)

        
        return pattern_match



def create_figure(fig_width, fig_height, num_subplot,
                subplots_axis_xlim, subplots_axis_ylim, subplots_titles):
    """
    args:
        fig_width:   the width of the figure
        fig_height:  the height of the figure
        num_subplot: num of subplot in the figure
        subplots_axis_xlim: x limit for each subplot. The value can be a list: [lower bound, upper bound],
                            or nested list: [[lower bound, upper bound], [lower bound, upper bound], ...],
                            for the length of the nested list should be equal to the number of the subplots.
                            If only one list is given, all subplots would apply with the same value.
        subplots_axis_ylim: y limit for each subplot. Same rule as subplots_axis_xlim.
        subplots_titles: a list of titles for each subplot.
    return:
        fig
        axs

    This function creates a plot with the basic configuration to save repetitive jobs.
    """
    fig, axs = plt.subplots(num_subplot, figsize=(fig_width, fig_height))
    

    for n in range(num_subplot):
        if all(isinstance(i, list) for i in subplots_axis_xlim):
            xlim = subplots_axis_xlim[n]
        else:
            xlim = subplots_axis_xlim
        axs[n].set_xlim(xlim)
        
        if all(isinstance(i, list) for i in subplots_axis_ylim):
            ylim = subplots_axis_ylim[n]
        else:
            ylim = subplots_axis_ylim
        axs[n].set_ylim(ylim)
        
        axs[n].tick_params(axis='both', which='major', labelsize=6)
        axs[n].set_title(subplots_titles[n], fontsize=8)
        axs[n].legend(loc='center left', bbox_to_anchor=(1, 0.5), prop={'size': 6})

    fig.tight_layout(pad=1)

    return fig, axs